<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>ä½è½¨å«æ˜Ÿè¿‡å¢ƒé¢„æŠ¥å·¥å…·ï¼ˆåŸºäº satellite.jsï¼‰</title>
  <style>
    body { font-family: "Microsoft YaHei", sans-serif; margin: 20px; }
    .input-group { margin: 10px 0; display: flex; align-items: center; gap: 10px; }
    label { display: inline-block; width: 150px; text-align: right; }
    input, button { padding: 5px; }
    table { border-collapse: collapse; margin-top: 20px; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    .station-table { border-collapse: collapse; margin: 10px 0; }
    .station-table th, .station-table td { border: 1px solid #ccc; padding: 5px; text-align: center; }
    .sort-btn { background: none; border: none; cursor: pointer; color: #0066cc; text-decoration: underline; font-size: 12px; }
    .sort-btn:hover { color: #004499; }
    .section { margin: 30px 0; padding: 20px; border: 1px solid #ddd; border-radius: 5px; }
    .section-title { font-size: 18px; margin-bottom: 15px; }
    .geo-station-table {
      border-collapse: collapse;
      width: 100%;
      margin: 10px 0;
    }
    .geo-station-table th, .geo-station-table td {
      border: 1px solid #ccc;
      padding: 5px;
      text-align: center;
    }
    .geo-station-table .header {
      background-color: #f0f0f0;
      font-weight: bold;
    }
    .geo-station-table .label {
      font-weight: bold;
    }
    .el-threshold-warning {
      color: #e67e22;
      font-weight: bold;
      margin-left: 10px;
    }
    .filtered-row {
      background-color: #ffebee;
      opacity: 0.7;
    }
    .filter-note {
      color: #e67e22;
      font-weight: bold;
      margin: 5px 0;
    }
  </style>
</head>
<body>
  <h2>ğŸ›°ï¸ ä½è½¨å«æ˜Ÿè¿‡å¢ƒé¢„æŠ¥å·¥å…·ï¼ˆåŸºäº satellite.jsï¼‰</h2>

  <!-- ç¬¬ä¸€éƒ¨åˆ†ï¼šè¿‡å¢ƒé¢„æŠ¥ -->
  <div class="section">
    <h3 class="section-title">ğŸ“ˆ ç¬¬ä¸€éƒ¨åˆ†ï¼šæœªæ¥7å¤©è¿‡å¢ƒé¢„æŠ¥</h3>
    
    <div class="input-group">
      <label>TLE Line 1:</label>
      <input id="tle1" type="text" size="80" value="1 51950U 22023E   25354.62739178  .00000031  00000+0  16468-3 0  9992
">
    </div>
    <div class="input-group">
      <label>TLE Line 2:</label>
      <input id="tle2" type="text" size="80" value="2 51950  63.4633  60.0150 0143486 348.6271  11.1529 13.56245337197810">
    </div>
    <div class="input-group">
      <label>å½“åœ°æ—¶é—´ï¼š</label>
      <input id="localTime" type="text" placeholder="YYYY/MM/DD HH:MM:SS">
      <button onclick="resetToCurrentTime()" style="padding: 2px 5px; font-size: 12px;">ğŸ•’ é‡ç½®ä¸ºå½“å‰æ—¶é—´</button>
    </div>
    <div class="input-group">
      <label>æ—¶åŒºï¼ˆUTC+Xï¼‰ï¼š</label>
      <input id="timezone" type="number" value="8">
    </div>
    <div class="input-group">
      <label>ä»°è§’é˜ˆå€¼ (Â°):</label>
      <input id="elThreshold" type="number" min="0" max="90" step="0.1" value="15">
      <span class="el-threshold-warning">ï¼ˆ0-90åº¦ï¼‰</span>
    </div>

    <!-- åœ°çƒç«™ç»çº¬åº¦è¡¨ -->
    <div style="margin: 20px 0;">
      <table class="geo-station-table">
        <tr>
          <th colspan="11" class="header">åœ°çƒç«™ç»çº¬åº¦è¡¨</th>
        </tr>
        <tr>
          <td class="label">åºå·</td>
          <td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td><td>10</td>
        </tr>
        <tr>
          <td class="label">ç»åº¦</td>
          <td><input id="lon1" type="number" step="0.01" value="20"></td>
          <td><input id="lon2" type="number" step="0.01" value="30"></td>
          <td><input id="lon3" type="number" step="0.01" value="40"></td>
          <td><input id="lon4" type="number" step="0.01" value="50"></td>
          <td><input id="lon5" type="number" step="0.01" value="60"></td>
          <td><input id="lon6" type="number" step="0.01" value="70"></td>
          <td><input id="lon7" type="number" step="0.01" value="80"></td>
          <td><input id="lon8" type="number" step="0.01" value="90"></td>
          <td><input id="lon9" type="number" step="0.01" value="100"></td>
          <td><input id="lon10" type="number" step="0.01" value="110"></td>
        </tr>
        <tr>
          <td class="label">çº¬åº¦</td>
          <td><input id="lat1" type="number" step="0.01" value="5"></td>
          <td><input id="lat2" type="number" step="0.01" value="10"></td>
          <td><input id="lat3" type="number" step="0.01" value="15"></td>
          <td><input id="lat4" type="number" step="0.01" value="20"></td>
          <td><input id="lat5" type="number" step="0.01" value="25"></td>
          <td><input id="lat6" type="number" step="0.01" value="30"></td>
          <td><input id="lat7" type="number" step="0.01" value="35"></td>
          <td><input id="lat8" type="number" step="0.01" value="40"></td>
          <td><input id="lat9" type="number" step="0.01" value="45"></td>
          <td><input id="lat10" type="number" step="0.01" value="50"></td>
        </tr>
      </table>
    </div>

    <button onclick="calculatePasses()">ğŸš€ å¼€å§‹è®¡ç®—è¿‡å¢ƒ</button>
    <button onclick="exportToCSV()">ğŸ“¥ å¯¼å‡ºè¿‡å¢ƒè¡¨åˆ° CSV</button>

    <div id="passResult"></div>
  </div>

  <!-- ç¬¬äºŒéƒ¨åˆ†ï¼šå«æ˜Ÿåæ ‡ä¸å¤šæ™®å‹’è®¡ç®— -->
  <div class="section">
    <h3 class="section-title">ğŸ“¡ ç¬¬äºŒéƒ¨åˆ†ï¼šè¿‡å¢ƒå«æ˜Ÿåæ ‡ä¸å¤šæ™®å‹’è®¡ç®—</h3>

    <!-- è¾“å…¥åŒºåŸŸè°ƒæ•´ä¸ºä¸€è¡Œ -->
    <div style="display: flex; gap: 10px; align-items: center; margin: 10px 0;">
      <div>
        <label>è¿‡å¢ƒåºå·ï¼š</label>
        <input id="selectedPassIndex" type="number" min="1" value="1" onchange="autoFillStation()" style="width: 60px;">
      </div>
      <div>
        <label>åœ°çƒç«™åºå·ï¼š</label>
        <input id="selectedStationId" type="number" min="1" max="10" value="1" onchange="updateLonLat()" style="width: 60px;">
      </div>
      <div>
        <label>åœ°çƒç«™ç»åº¦ï¼š</label>
        <input id="selectedLon" type="number" step="0.01" value="40" style="width: 60px;">
      </div>
      <div>
        <label>åœ°çƒç«™çº¬åº¦ï¼š</label>
        <input id="selectedLat" type="number" step="0.01" value="15" style="width: 60px;">
      </div>
      <div>
        <label>å‘å°„é¢‘ç‡ï¼ˆMHzï¼‰ï¼š</label>
        <input id="txFreq" type="number" step="0.1" value="145" style="width: 60px;">
      </div>
      <div>
        <label>æ¥æ”¶é¢‘ç‡ï¼ˆMHzï¼‰ï¼š</label>
        <input id="rxFreq" type="number" step="0.1" value="145" style="width: 60px;">
      </div>
      <div>
        <button onclick="calculateDoppler()">ğŸš€ å¼€å§‹è®¡ç®—å«æ˜Ÿåæ ‡ä¸å¤šæ™®å‹’</button>
      </div>
      <div>
        <button onclick="exportDopplerToCSV()">ğŸ“¥ å¯¼å‡ºè¿‡å¢ƒè¡¨åˆ° CSV</button>
      </div>
    </div>

    <div id="dopplerResult"></div>
  </div>

  <pre id="debug" style="font-size:12px; color:#666; display:none;"></pre>

  <!-- å¼•å…¥ satellite.js -->
  <script src="satellite.js"></script>
  <script>
    // ========== æ–°å¢ä»£ç å¼€å§‹ ==========
    // é¡µé¢åŠ è½½å®Œæˆåè®¾ç½®å½“å‰æ—¶é—´
    document.addEventListener('DOMContentLoaded', function() {
      // è·å–å½“å‰æ—¶é—´
      const now = new Date();
      
      // æ ¼å¼åŒ–ä¸º "YYYY/MM/DD HH:mm:ss"
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const day = String(now.getDate()).padStart(2, '0');
      const hours = String(now.getHours()).padStart(2, '0');
      const minutes = String(now.getMinutes()).padStart(2, '0');
      const seconds = String(now.getSeconds()).padStart(2, '0');
      
      const formattedTime = `${year}/${month}/${day} ${hours}:${minutes}:${seconds}`;
      
      // è®¾ç½®è¾“å…¥æ¡†çš„å€¼
      document.getElementById('localTime').value = formattedTime;
      
      // ä¿å­˜åˆå§‹åŠ è½½æ—¶é—´
      window.initialLoadTime = formattedTime;
    });
    
    // é‡ç½®ä¸ºå½“å‰æ—¶é—´çš„å‡½æ•°
    function resetToCurrentTime() {
      document.getElementById('localTime').value = window.initialLoadTime;
    }
    // ========== æ–°å¢ä»£ç ç»“æŸ ==========
    // å…¨å±€å˜é‡ç”¨äºå­˜å‚¨æ’åºçŠ¶æ€å’Œè¿‡å¢ƒæ•°æ®
    let sortColumn = null;
    let sortDirection = 'asc';
    let allPasses = [];
    let satrec = null; // å…¨å±€å«æ˜Ÿè½¨é“å¯¹è±¡
    let currentElThreshold = 10; // é»˜è®¤ä»°è§’é˜ˆå€¼

    // è‡ªåŠ¨å¡«å……åœ°çƒç«™ä¿¡æ¯
    function autoFillStation() {
      const selectedPassIndex = parseInt(document.getElementById('selectedPassIndex').value) - 1;
      if (selectedPassIndex >= 0 && selectedPassIndex < allPasses.length) {
        const pass = allPasses[selectedPassIndex];
        const stationId = pass.stationId;
        document.getElementById('selectedStationId').value = stationId;

        // æ ¹æ® stationId å¡«å……ç»åº¦å’Œçº¬åº¦
        const lon = parseFloat(document.getElementById(`lon${stationId}`).value);
        const lat = parseFloat(document.getElementById(`lat${stationId}`).value);
        document.getElementById('selectedLon').value = lon;
        document.getElementById('selectedLat').value = lat;
      }
    }

    // å½“åœ°çƒç«™åºå·æ”¹å˜æ—¶ï¼Œæ›´æ–°ç»åº¦å’Œçº¬åº¦
    function updateLonLat() {
      const stationId = parseInt(document.getElementById('selectedStationId').value);
      if (stationId >= 1 && stationId <= 10) {
        const lon = parseFloat(document.getElementById(`lon${stationId}`).value);
        const lat = parseFloat(document.getElementById(`lat${stationId}`).value);
        document.getElementById('selectedLon').value = lon;
        document.getElementById('selectedLat').value = lat;
      }
    }

    // ç¬¬ä¸€éƒ¨åˆ†ï¼šè®¡ç®—è¿‡å¢ƒ
    function calculatePasses() {
      try {
        const tle1 = document.getElementById('tle1').value;
        const tle2 = document.getElementById('tle2').value;
        const localTimeStr = document.getElementById('localTime').value;
        const timezone = parseFloat(document.getElementById('timezone').value);
        currentElThreshold = parseFloat(document.getElementById('elThreshold').value);

        // éªŒè¯ä»°è§’é˜ˆå€¼
        if (isNaN(currentElThreshold) || currentElThreshold < 0 || currentElThreshold > 90) {
          throw new Error("ä»°è§’é˜ˆå€¼å¿…é¡»åœ¨0åˆ°90åº¦ä¹‹é—´");
        }

        // è§£ææœ¬åœ°æ—¶é—´ â†’ UTC
        const localDate = new Date(localTimeStr.replace(/\//g, '-'));
        if (isNaN(localDate)) throw new Error("æ—¶é—´æ ¼å¼é”™è¯¯ï¼Œè¯·ç”¨ YYYY/MM/DD HH:MM:SS");
        const utcDate = new Date(localDate.getTime() - timezone * 3600 * 1000);

        // åˆå§‹åŒ–å«æ˜Ÿ
        satrec = satellite.twoline2satrec(tle1, tle2);
        if (satrec.error) throw new Error("TLE è§£æå¤±è´¥: " + satrec.error);

        // è¿‡å¢ƒé¢„æŠ¥ï¼ˆé’ˆå¯¹æ‰€æœ‰10ä¸ªåœ°é¢ç«™ï¼‰
        allPasses = [];
        const stationCount = 10;

        for (let i = 1; i <= stationCount; i++) {
          const lon = parseFloat(document.getElementById(`lon${i}`).value);
          const lat = parseFloat(document.getElementById(`lat${i}`).value);
          const obsGeod = {
            longitude: satellite.radiansLong(lon),
            latitude: satellite.radiansLat(lat),
            height: 0
          };

          const passes = predictPasses(satrec, obsGeod, utcDate, 7, i, currentElThreshold);
          allPasses.push(...passes);
        }

        // ç”Ÿæˆ HTML è¡¨æ ¼
        let html = `<h3>ğŸ“ˆ æœªæ¥7å¤©è¿‡å¢ƒé¢„æŠ¥ï¼ˆä»°è§’ > ${currentElThreshold.toFixed(1)}Â°ï¼‰</h3>`;
        if (allPasses.length === 0) {
          html += `<p>æœªæ¥7å¤©æ— è¿‡å¢ƒï¼ˆä»°è§’é˜ˆå€¼: ${currentElThreshold.toFixed(1)}Â°ï¼‰ã€‚</p>`;
        } else {
          // æ·»åŠ æ’åºè¡¨å¤´
          html += `
          <table id="passTable">
            <thead>
              <tr>
                <th>è¿‡å¢ƒåºå· <button class="sort-btn" onclick="sortTable(0)">â†‘â†“</button></th>
                <th>å¼€å§‹æ—¶é—´ (å½“åœ°) <button class="sort-btn" onclick="sortTable(1)">â†‘â†“</button></th>
                <th>ç»“æŸæ—¶é—´ (å½“åœ°) <button class="sort-btn" onclick="sortTable(2)">â†‘â†“</button></th>
                <th>æŒç»­æ—¶é—´ <button class="sort-btn" onclick="sortTable(3)">â†‘â†“</button></th>
                <th>æœ€é«˜ä»°è§’ (Â°) <button class="sort-btn" onclick="sortTable(4)">â†‘â†“</button></th>
                <th>åœ°çƒç«™åºå· <button class="sort-btn" onclick="sortTable(5)">â†‘â†“</button></th>
              </tr>
            </thead>
            <tbody id="passTableBody">
          `;

          // å¡«å……æ•°æ®
          allPasses.forEach((p, i) => {
            const dur = (p.end - p.start) / 60000; // åˆ†é’Ÿ
            html += `<tr>
                       <td>${i+1}</td>
                       <td>${p.start.toLocaleString()}</td>
                       <td>${p.end.toLocaleString()}</td>
                       <td>${dur.toFixed(1)} åˆ†é’Ÿ</td>
                       <td>${p.maxElDeg.toFixed(2)}</td>
                       <td>${p.stationId}</td>
                     </tr>`;
          });

          html += `</tbody></table>`;
        }

        document.getElementById('passResult').innerHTML = html;
        window._lastResult = { allPasses };
    document.getElementById('selectedPassIndex').value = "1";
  // å¦‚æœæœ‰è‡³å°‘ä¸€ä¸ªè¿‡å¢ƒè®°å½•ï¼Œè‡ªåŠ¨å¡«å……åœ°çƒç«™ä¿¡æ¯
    if (allPasses.length > 0) {
      autoFillStation();
    }

      } catch (e) {
        alert("âŒ è®¡ç®—å‡ºé”™ï¼š" + e.message);
        console.error(e);
        document.getElementById('debug').textContent = e.stack;
        document.getElementById('debug').style.display = 'block';
      }
    }

    // æ’åºå‡½æ•°
    function sortTable(columnIndex) {
      const table = document.getElementById('passTable');
      const tbody = table.querySelector('tbody');
      const rows = Array.from(tbody.querySelectorAll('tr'));

      // ç¡®å®šæ’åºæ–¹å‘
      if (sortColumn === columnIndex) {
        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
      } else {
        sortColumn = columnIndex;
        sortDirection = 'asc';
      }

      // æ ¹æ®åˆ—ç´¢å¼•å’Œæ–¹å‘æ’åº
      rows.sort((a, b) => {
        let aValue = a.cells[columnIndex].innerText;
        let bValue = b.cells[columnIndex].innerText;

        // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœåˆ—æ˜¯æ•°å­—æˆ–æ—¥æœŸï¼Œåˆ™è½¬æ¢ç±»å‹
        if (columnIndex === 0 || columnIndex === 3 || columnIndex === 4 || columnIndex === 5) {
          // æ•°å­—åˆ—
          aValue = parseFloat(aValue.replace(/[^\d.-]/g, ''));
          bValue = parseFloat(bValue.replace(/[^\d.-]/g, ''));
        } else if (columnIndex === 1 || columnIndex === 2) {
          // æ—¥æœŸåˆ—
          aValue = new Date(aValue.replace(/\//g, '-')).getTime();
          bValue = new Date(bValue.replace(/\//g, '-')).getTime();
        }

        // æ¯”è¾ƒ
        let comparison = 0;
        if (aValue < bValue) {
          comparison = -1;
        } else if (aValue > bValue) {
          comparison = 1;
        }

        return sortDirection === 'asc' ? comparison : -comparison;
      });

      // é‡æ–°æ’å…¥è¡Œ
      rows.forEach(row => tbody.appendChild(row));
    }

    // è¿‡å¢ƒé¢„æµ‹ï¼ˆæ¯åˆ†é’Ÿæ‰«æï¼‰ï¼Œè¿”å›æœ€é«˜ä»°è§’ & åœ°çƒç«™åºå·
    function predictPasses(satrec, obsGeod, startTime, days, stationId, elThreshold) {
      const passes = [];
      let current = new Date(startTime);
      const end = new Date(startTime.getTime() + days * 24 * 3600 * 1000);
      let inPass = false;
      let passStart;
      let maxElDeg = 0;

      while (current < end) {
        const posVel = satellite.propagate(satrec, current);
        if (posVel.position) {
          const gmst = satellite.gstime(current);
          const posEcf = satellite.eciToEcf(posVel.position, gmst);
          const look = satellite.ecfToLookAngles(obsGeod, posEcf);
          const elDeg = satellite.radiansToDegrees(look.elevation);

          // ä½¿ç”¨åŠ¨æ€ä»°è§’é˜ˆå€¼
          if (elDeg > elThreshold && !inPass) {
            inPass = true;
            passStart = new Date(current);
            maxElDeg = elDeg;
          } else if (elDeg <= elThreshold && inPass) {
            inPass = false;
            passes.push({
              start: passStart,
              end: new Date(current),
              maxElDeg: maxElDeg,
              stationId: stationId
            });
          } else if (inPass && elDeg > maxElDeg) {
            maxElDeg = elDeg;
          }
        }
        current.setMinutes(current.getMinutes() + 1);
      }
      
      // å¤„ç†æœ€åä¸€æ®µè¿‡å¢ƒ
      if (inPass) {
        passes.push({
          start: passStart,
          end: new Date(end),
          maxElDeg: maxElDeg,
          stationId: stationId
        });
      }
      
      return passes;
    }

    // å¯¼å‡ºç¬¬ä¸€éƒ¨åˆ†è¿‡å¢ƒè¡¨
    function exportToCSV() {
      if (!window._lastResult || !window._lastResult.allPasses) {
        alert("è¯·å…ˆç‚¹å‡»ã€Œå¼€å§‹è®¡ç®—è¿‡å¢ƒã€");
        return;
      }
      const { allPasses } = window._lastResult;

      // ç”Ÿæˆ CSV å†…å®¹
      let csv = `ä»°è§’é˜ˆå€¼(Â°),${currentElThreshold.toFixed(1)}\n`;
      csv += "è¿‡å¢ƒåºå·,å¼€å§‹æ—¶é—´(UTC),ç»“æŸæ—¶é—´(UTC),æŒç»­æ—¶é—´(åˆ†é’Ÿ),æœ€é«˜ä»°è§’(Â°),åœ°çƒç«™åºå·\n";

      allPasses.forEach((p, i) => {
        const dur = (p.end - p.start) / 60000; // åˆ†é’Ÿ
        const startUTC = p.start.toISOString();
        const endUTC = p.end.toISOString();
        csv += `${i+1},"${startUTC}","${endUTC}",${dur.toFixed(1)},${p.maxElDeg.toFixed(2)},${p.stationId}\n`;
      });

      // æ·»åŠ BOMç¡®ä¿Excelæ­£ç¡®è¯†åˆ«UTF-8
      const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
      const blob = new Blob([bom, csv], { type: 'text/csv;charset=utf-8;' });

      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `Passes_${currentElThreshold.toFixed(1)}deg_${new Date().toISOString().slice(0,16).replace(/:/g,'')}.csv`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 100);
    }

// ç¬¬äºŒéƒ¨åˆ†ï¼šè®¡ç®—å«æ˜Ÿåæ ‡ä¸å¤šæ™®å‹’
function calculateDoppler() {
  try {
    // è·å–ç”¨æˆ·è¾“å…¥
    const selectedPassIndex = parseInt(document.getElementById('selectedPassIndex').value) - 1; // è½¬ä¸ºæ•°ç»„ç´¢å¼•
    const selectedStationId = parseInt(document.getElementById('selectedStationId').value);
    const selectedLon = parseFloat(document.getElementById('selectedLon').value);
    const selectedLat = parseFloat(document.getElementById('selectedLat').value);
    const txFreq = parseFloat(document.getElementById('txFreq').value);
    const rxFreq = parseFloat(document.getElementById('rxFreq').value);

    // éªŒè¯è¾“å…¥
    if (selectedPassIndex < 0 || selectedPassIndex >= allPasses.length) {
      throw new Error("è¯·é€‰æ‹©æœ‰æ•ˆçš„è¿‡å¢ƒåºå·");
    }
    if (selectedStationId < 1 || selectedStationId > 10) {
      throw new Error("åœ°çƒç«™åºå·å¿…é¡»åœ¨ 1-10 ä¹‹é—´");
    }

    // è·å–é€‰ä¸­çš„è¿‡å¢ƒè®°å½•
    const selectedPass = allPasses[selectedPassIndex];

    // åˆ›å»ºåœ°é¢ç«™åœ°ç†åæ ‡å¯¹è±¡
    const obsGeod = {
      longitude: satellite.radiansLong(selectedLon),
      latitude: satellite.radiansLat(selectedLat),
      height: 0
    };

    // ç”Ÿæˆæ—¶é—´ç‚¹åˆ—è¡¨ï¼šå¼€å§‹ã€ç»“æŸã€æœ€å¤§ä»°è§’ã€ä»¥åŠä¸­é—´æ¯éš”1ç§’
    const timePoints = [];
    const startTime = selectedPass.start;
    const endTime = selectedPass.end;
    const durationMs = endTime.getTime() - startTime.getTime();

    // æ·»åŠ å¼€å§‹æ—¶é—´
    timePoints.push({ time: new Date(startTime), label: "å¼€å§‹æ—¶é—´ï¼ˆå½“åœ°ï¼‰" });

    // æ·»åŠ ç»“æŸæ—¶é—´
    timePoints.push({ time: new Date(endTime), label: "ç»“æŸæ—¶é—´ï¼ˆå½“åœ°ï¼‰" });

    // æ·»åŠ æœ€å¤§ä»°è§’æ—¶é—´ï¼ˆéœ€è®¡ç®—ï¼‰
    let maxElTimePoint = { time: new Date(startTime), label: "æœ€å¤§ä»°è§’æ—¶é—´", maxEl: 0 };
    let current = new Date(startTime);
    while (current <= endTime) {
      const posVel = satellite.propagate(satrec, current);
      if (posVel.position) {
        const gmst = satellite.gstime(current);
        const posEcf = satellite.eciToEcf(posVel.position, gmst);
        const look = satellite.ecfToLookAngles(obsGeod, posEcf);
        const elDeg = satellite.radiansToDegrees(look.elevation);
        if (elDeg > maxElTimePoint.maxEl) {
          maxElTimePoint.time = new Date(current);
          maxElTimePoint.maxEl = elDeg;
        }
      }
      current.setSeconds(current.getSeconds() + 1);
    }
    timePoints.push(maxElTimePoint);

    // æ·»åŠ ä¸­é—´æ—¶é—´ç‚¹ï¼ˆæ¯éš”1ç§’ï¼‰
    current = new Date(startTime);
    while (current < endTime) {
      current.setSeconds(current.getSeconds() + 1);
      if (current < endTime) {
        timePoints.push({ time: new Date(current), label: `å¼€å§‹æ—¶é—´+${Math.floor((current.getTime() - startTime.getTime()) / 1000)}ç§’` });
      }
    }

    // å¯¹æ—¶é—´ç‚¹æŒ‰æ—¶é—´æ’åº
    timePoints.sort((a, b) => a.time - b.time);

    // è®¡ç®—æ¯ä¸ªæ—¶é—´ç‚¹çš„æ•°æ®
    const dopplerData = [];
    const c = 299792.458; // km/s
    const timezoneOffset = parseFloat(document.getElementById('timezone').value);

    for (const point of timePoints) {
      const time = point.time;
      const posVel = satellite.propagate(satrec, time);
      if (!posVel.position) continue;

      const gmst = satellite.gstime(time);
      const posEcf = satellite.eciToEcf(posVel.position, gmst);
      const velEcf = satellite.eciToEcf(posVel.velocity, gmst, time.getTime()/1000);

      // è®¡ç®—æ˜Ÿä¸‹ç‚¹
      const geod = satellite.eciToGeodetic(posVel.position, gmst);
      const subSatLon = satellite.degreesLong(geod.longitude);
      const subSatLat = satellite.degreesLat(geod.latitude);
      const height = geod.height;

      // è®¡ç®—è·ç¦»ã€è·ç¦»å˜åŒ–ç‡
      const obsEcf = satellite.geodeticToEcf(obsGeod);
      const dx = posEcf.x - obsEcf.x;
      const dy = posEcf.y - obsEcf.y;
      const dz = posEcf.z - obsEcf.z;
      const range = Math.sqrt(dx*dx + dy*dy + dz*dz); // km
      const rangeRate = (dx*velEcf.x + dy*velEcf.y + dz*velEcf.z) / range; // km/s

      // å¤šæ™®å‹’é¢‘å
      const dopplerTx = -(rangeRate / c) * txFreq * 1e6;
      const dopplerRx = -(rangeRate / c) * rxFreq * 1e6;

      // ç®€åŒ–å¤šæ™®å‹’å˜åŒ–ç‡ï¼ˆå·®åˆ†æ³•ï¼Œ1ç§’æ­¥é•¿ï¼‰
      const dt = 1.0; // sec
      const nextDate = new Date(time.getTime() + dt * 1000);
      const nextPosVel = satellite.propagate(satrec, nextDate);
      if (nextPosVel.position) {
        const nextGmst = satellite.gstime(nextDate);
        const nextVelEcf = satellite.eciToEcf(nextPosVel.velocity, nextGmst);
        const nextPosEcf = satellite.eciToEcf(nextPosVel.position, nextGmst);
        const nextDx = nextPosEcf.x - obsEcf.x;
        const nextDy = nextPosEcf.y - obsEcf.y;
        const nextDz = nextPosEcf.z - obsEcf.z;
        const nextRange = Math.sqrt(nextDx * nextDx + nextDy * nextDy + nextDz * nextDz);
        const nextRangeRate = (nextDx * nextVelEcf.x + nextDy * nextVelEcf.y + nextDz * nextVelEcf.z) / nextRange;
        const rangeRateAcc = (nextRangeRate - rangeRate) / dt; // km/sÂ²
        const dopplerRateTx = -(rangeRateAcc / c) * txFreq * 1e6;
        const dopplerRateRx = -(rangeRateAcc / c) * rxFreq * 1e6;
        
        // è®¡ç®—ä»°è§’å’Œæ–¹ä½è§’ (æ­£åŒ—ä¸º0Â°ï¼Œæ­£ä¸œä¸º90Â°)
        const lookAngles = satellite.ecfToLookAngles(obsGeod, posEcf);
        const elevation = satellite.radiansToDegrees(lookAngles.elevation);
        
        // ä¿®æ­£æ–¹ä½è§’ï¼šæ­£åŒ—ä¸º0Â°ï¼Œæ­£ä¸œä¸º90Â°
        let azimuth = satellite.radiansToDegrees(lookAngles.azimuth);
        // satellite.jsè¿”å›çš„æ–¹ä½è§’æ˜¯æ­£åŒ—ä¸º0Â°ï¼Œé¡ºæ—¶é’ˆå¢åŠ 
        // æ‰€ä»¥ä¸éœ€è¦é¢å¤–è½¬æ¢ï¼Œç›´æ¥æ ‡å‡†åŒ–åˆ°0-360åº¦èŒƒå›´
        azimuth = azimuth % 360;
        if (azimuth < 0) azimuth += 360;
        
        dopplerData.push({
          timeLabel: point.label,
          time: time,
          utcTime: new Date(time.getTime() - timezoneOffset * 3600 * 1000), // UTCæ—¶é—´
          subSatLon: subSatLon,
          subSatLat: subSatLat,
          height: height,
          dopplerTx: dopplerTx,
          dopplerRateTx: dopplerRateTx,
          dopplerRx: dopplerRx,
          dopplerRateRx: dopplerRateRx,
          elevation: elevation,
          azimuth: azimuth, // ä¿®æ­£åçš„æ–¹ä½è§’
          distance: range,
          delay: (range / c) * 1000
        });
      } else {
        // è®¡ç®—ä»°è§’å’Œæ–¹ä½è§’ (å¤±è´¥æƒ…å†µ)
        const lookAngles = satellite.ecfToLookAngles(obsGeod, posEcf);
        const elevation = satellite.radiansToDegrees(lookAngles.elevation);
        
        // ä¿®æ­£æ–¹ä½è§’
        let azimuth = satellite.radiansToDegrees(lookAngles.azimuth);
        azimuth = azimuth % 360;
        if (azimuth < 0) azimuth += 360;
        
        dopplerData.push({
          timeLabel: point.label,
          time: time,
          utcTime: new Date(time.getTime() - timezoneOffset * 3600 * 1000), // UTCæ—¶é—´
          subSatLon: subSatLon,
          subSatLat: subSatLat,
          height: height,
          dopplerTx: dopplerTx,
          dopplerRateTx: 0,
          dopplerRx: dopplerRx,
          dopplerRateRx: 0,
          elevation: elevation,
          azimuth: azimuth, // ä¿®æ­£åçš„æ–¹ä½è§’
          distance: range,
          delay: (range / c) * 1000
        });
      }
    }

    // è¿‡æ»¤æ‰ä»°è§’ä½äºé˜ˆå€¼çš„è¡Œ
    const filteredData = dopplerData.filter(data => data.elevation >= currentElThreshold);
    
    // å¦‚æœè¿‡æ»¤åä¸ºç©ºï¼Œæ˜¾ç¤ºæç¤º
    if (filteredData.length === 0) {
      document.getElementById('dopplerResult').innerHTML = 
        `<div class="filter-note">âš ï¸ æœªæ‰¾åˆ°ä»°è§’ â‰¥ ${currentElThreshold.toFixed(1)}Â° çš„æ•°æ®ç‚¹</div>`;
      return;
    }

    // ç”Ÿæˆ HTML è¡¨æ ¼
    let html = `<h3>ğŸ“¡ è¿‡å¢ƒå«æ˜Ÿåæ ‡ä¸å¤šæ™®å‹’è¡¨æ ¼ï¼ˆä»°è§’é˜ˆå€¼: ${currentElThreshold.toFixed(1)}Â°ï¼‰</h3>`;
    html += `<div class="filter-note">æ˜¾ç¤ºäº† ${filteredData.length} ä¸ªç¬¦åˆæ¡ä»¶çš„æ•°æ®ç‚¹ï¼ˆæ€»è®¡ç®—ç‚¹: ${dopplerData.length}ï¼‰</div>`;
    html += `<table>
      <tr>
        <th>åºå·</th>
        <th>æ—¶é—´ (å½“åœ°)</th>
        <th>UTCæ—¶é—´</th> <!-- æ–°å¢UTCæ—¶é—´åˆ— -->
        <th>æ˜Ÿåœ°è·ç¦» (km)</th>
        <th>æ˜Ÿä¸‹ç‚¹ç»åº¦</th>
        <th>æ˜Ÿä¸‹ç‚¹çº¬åº¦</th>
        <th>è·åœ°é¢é«˜åº¦ï¼ˆkmï¼‰</th>
        <th>ä»°è§’</th> <!-- ç§»åˆ°é«˜åº¦åˆ—ä¹‹å -->
        <th>æ–¹ä½</th> <!-- ç§»åˆ°é«˜åº¦åˆ—ä¹‹å -->
        <th>å‘å°„é¢‘å</th>
        <th>å‘å°„é¢‘ç‡å˜åŒ–ç‡</th>
        <th>æ¥æ”¶é¢‘å</th>
        <th>æ¥æ”¶é¢‘ç‡å˜åŒ–ç‡</th>
        <th>ä¼ è¾“æ—¶é•¿ (ms)</th> <!-- ç§»åˆ°æœ€å -->
      </tr>`;

    // æ·»åŠ è¿‡æ»¤åçš„æ•°æ®
    filteredData.forEach((data, i) => {
      const localTimeStr = data.time.toLocaleString('zh-CN', { 
        year: 'numeric', month: '2-digit', day: '2-digit', 
        hour: '2-digit', minute: '2-digit', second: '2-digit' 
      }).replace(/-/g, '/');
      
      // æ ¼å¼åŒ–UTCæ—¶é—´
      const utcTimeStr = data.utcTime.toISOString().replace('T', ' ').substring(0, 19);
      
      html += `<tr>
                 <td>${i+1}</td>
                 <td>${localTimeStr}</td>
                 <td>${utcTimeStr}</td> <!-- UTCæ—¶é—´ -->
                 <td>${data.distance.toFixed(2)}</td>
                 <td>${data.subSatLon.toFixed(4)}</td>
                 <td>${data.subSatLat.toFixed(4)}</td>
                 <td>${data.height.toFixed(2)}</td>
                 <td>${data.elevation.toFixed(2)}</td> <!-- ä»°è§’ç§»åˆ°è¿™é‡Œ -->
                 <td>${data.azimuth.toFixed(2)}</td> <!-- æ–¹ä½ç§»åˆ°è¿™é‡Œ -->
                 <td>${data.dopplerTx.toFixed(1)}</td>
                 <td>${data.dopplerRateTx.toFixed(3)}</td>
                 <td>${data.dopplerRx.toFixed(1)}</td>
                 <td>${data.dopplerRateRx.toFixed(3)}</td>
                 <td>${data.delay.toFixed(2)}</td> <!-- ä¼ è¾“æ—¶é•¿ç§»åˆ°æœ€å -->
               </tr>`;
    });

    html += `</table>`;

    document.getElementById('dopplerResult').innerHTML = html;
    window._dopplerResult = { 
      dopplerData: filteredData,
      originalCount: dopplerData.length,
      filteredCount: filteredData.length
    };

  } catch (e) {
    alert("âŒ è®¡ç®—å‡ºé”™ï¼š" + e.message);
    console.error(e);
    document.getElementById('debug').textContent = e.stack;
    document.getElementById('debug').style.display = 'block';
  }
}

// å¯¼å‡ºç¬¬äºŒéƒ¨åˆ†å¤šæ™®å‹’è¡¨
function exportDopplerToCSV() {
  if (!window._dopplerResult || !window._dopplerResult.dopplerData) {
    alert("è¯·å…ˆç‚¹å‡»ã€Œå¼€å§‹è®¡ç®—å«æ˜Ÿåæ ‡ä¸å¤šæ™®å‹’ã€");
    return;
  }
  
  const { dopplerData, originalCount, filteredCount } = window._dopplerResult;
  const timezoneOffset = parseFloat(document.getElementById('timezone').value);

  // ç”Ÿæˆ CSV å†…å®¹
  let csv = `ä»°è§’é˜ˆå€¼(Â°),${currentElThreshold.toFixed(1)}\n`;
  csv += `è¿‡æ»¤ä¿¡æ¯,æ˜¾ç¤ºäº† ${filteredCount} ä¸ªç¬¦åˆæ¡ä»¶çš„æ•°æ®ç‚¹ï¼ˆæ€»è®¡ç®—ç‚¹: ${originalCount}ï¼‰\n`;
  // åˆ—é¡ºåºä¿®æ”¹
  csv += "åºå·,æ—¶é—´ (å½“åœ°),UTCæ—¶é—´,æ˜Ÿåœ°è·ç¦» (km),æ˜Ÿä¸‹ç‚¹ç»åº¦,æ˜Ÿä¸‹ç‚¹çº¬åº¦,è·åœ°é¢é«˜åº¦ï¼ˆkmï¼‰,ä»°è§’,æ–¹ä½,å‘å°„é¢‘å,å‘å°„é¢‘ç‡å˜åŒ–ç‡,æ¥æ”¶é¢‘å,æ¥æ”¶é¢‘ç‡å˜åŒ–ç‡,ä¼ è¾“æ—¶é•¿ (ms)\n";

  dopplerData.forEach((data, i) => {
    // æ ¼å¼åŒ–æ—¶é—´ä¸º "YYYY/MM/DD HH:MM:SS"
    const localTimeStr = data.time.toLocaleString('zh-CN', { 
      year: 'numeric', month: '2-digit', day: '2-digit', 
      hour: '2-digit', minute: '2-digit', second: '2-digit' 
    }).replace(/-/g, '/');
    
    // æ ¼å¼åŒ–UTCæ—¶é—´
    const utcTimeStr = data.utcTime.toISOString().replace('T', ' ').substring(0, 19);
    
    // åˆ—é¡ºåºè°ƒæ•´
    csv += `${i+1},"${localTimeStr}","${utcTimeStr}",${data.distance.toFixed(2)},${data.subSatLon.toFixed(4)},${data.subSatLat.toFixed(4)},${data.height.toFixed(2)},${data.elevation.toFixed(2)},${data.azimuth.toFixed(2)},${data.dopplerTx.toFixed(1)},${data.dopplerRateTx.toFixed(3)},${data.dopplerRx.toFixed(1)},${data.dopplerRateRx.toFixed(3)},${data.delay.toFixed(2)}\n`;
  });

  // æ·»åŠ  BOM
  const bom = new Uint8Array([0xEF, 0xBB, 0xBF]);
  const blob = new Blob([bom, csv], { type: 'text/csv;charset=utf-8;' });

  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `Doppler_${currentElThreshold.toFixed(1)}deg_${new Date().toISOString().slice(0,16).replace(/:/g,'')}.csv`;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}
</script></body>
</html>